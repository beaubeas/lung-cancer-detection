**Use case:

Buld your own twitter management tool in a few commands:


When there is a new tweet about mindsdb, and its not spam and its positive:
- I'd like to like it 
- I'd like respond with a comment (autogenerated by gpt-3)


Integration:

'''
# Should be able to create a twitter database
CREATE DATABASE my_twitter 
USING 
ENGINE = 'twitter'
AND PARAMETERS = {
  "bearer_token": "twitter bearer TOKEN",  --- if none provided uses one from conf
};



# lets search for tweets that contain or hashtag the word mindsdb

SELECT id, created_at, from,  text FROM my_twitter.tweets WHERE query = 'mindsdb or #mindsdb' AND created_at > 'somedate' AND exclude = ['retweets'] limit 100;

# we and do this same query using a native query
# this should handle authentication and pagiantion for us
SELECT id, created_at, from, teext FROM my_twitter (
  {
    method:'GET',
    url:'https://api.twitter.com/2/tweets/search/all',
    payload: {
        query: 'mindsdb OR #mindsdb',
        exclude: ['retweets'],
        start_time: 'somedate',
        max_results: 100
    }
  }
);

# to keep things organized lets create a VIEW that gives you the latest tweets by context
# this view has a trick, which is that it acts as a stream, 
# which means that everytime you query on this view, it only gives you new results.
#
# the way this works is a new function TOP_FROM_LAST_RUN(<column_name>)


CREATE VIEW mindsdb.latest_tweets
AS (
    SELECT 
        t.id AS tweet_id,
        t.created_at AS created_at, 
        t.from AS username, 
        t.text AS text
    FROM my_twitter.tweets t 
    WHERE 
        t.query = 'mindsdb or #mindsdb' 
        AND t.since_id = TOP_FROM_LAST_RUN("tweet_id")
)




# lets write some tweets
INSERT INTO my_twitter.tweets (in_reply_to_tweet_id, text)
VALUES 
    ('MindsDB is great! now its super simple to build ML powered apps'),
    ('Holy!! MindsDB is the best thing they have invented for developers doing ML'),
    ('Loving MindsDB, where can I learn more?'),
    ('Using #Mindsdb to write this tweet, testing a negative comment here: I hate soup!'),
    ("Started playing with MindsDB capabilities, let's see where it takes us!");

# lets create a machine learning model that uses open_ai to classify sentiment

CREATE MODEL mindsdb.sentiment_classifier                           
PREDICT sentiment                          
USING
  engine = 'huggingface',              
  model_name = 'cardiffnlp/twitter-roberta-base-sentiment', 
  input_column = 'text',        
  labels = ['positive', 'neutral', 'negative'];

# lets test it: get sentiment, for only those tweets with postitive sentiment

SELECT t.*, m.sentiment FROM my_twitter.tweets AS t WHERE query = 'mindsdb or #mindsdb' JOIN mindsdb.sentiment_classifier as m WHERE m.sentiment = 'positive' or m.sentiment = 'neutral' LIMIT 10

# now lets create a model with open ai that writes a response given a positive tweet


CREATE MODEL mindsdb.twitter_response_model                           
PREDICT response
USING
  engine = 'openai', 
  max_tokens = 200,             
  prompt = TEMPLATE('from tweet {{text}} by {{username}}, if their comment is a question invite them to join the MindsDB slack using this link http://bitly.com/abc. Otherwise, simply write a thank you message');

# you can test it
select response from mindsdb.twitter_response_model where username = '@pedro' and text = 'I love this, can I learn more?';

# lets test it with some of the tweets, so we are going to join that model with the query that we had worked before that get the positive and neutral comments
SELECT s.tweet_id, s.username, s.text, r.response FROM (
    SELECT t.id as tweet_id, t.created_at, t.from as username, t.text as text, m.sentiment 
    FROM my_twitter.tweets t 
    JOIN mindsdb.sentiment_classifier m 
    WHERE 
        m.sentiment IN ('positive', 'neutral')
        AND t.query = 'mindsdb or #mindsdb' 
    LIMIT 10
) s
JOIN mindsdb.twitter_response_model r 




# lets create the job

CREATE JOB auto_respond AS (

    INSERT INTO my_twitter.tweets (in_reply_to_tweet_id, text)

    SELECT 
        positive_tweets.tweet_id AS in_reply_to_tweet_id, 
        response_model.response AS text 
        FROM (
            SELECT 
                t.id AS tweet_id,
                t.created_at, 
                t.from as username, 
                t.text as text,
                m.sentiment 
            FROM my_twitter.latest_tweets t 
            JOIN mindsdb.sentiment_classifier m
            WHERE 
                m.sentiment IN ('positive', 'neutral')
                AND t.query = 'mindsdb or #mindsdb' 
                AND t.since_id = TOP_FROM_LAST_RUN(tweet_id)
        ) positive_tweets
    JOIN mindsdb.twitter_response_model response_model 

)
EVERY HOUR



# NEW things that we would need to do:

# Support INSERT INTO, say I want to respond to a tweet (with tweet_id)

INSERT INTO my_twitter.tweets (in_reply_to_tweet_id, text)
VALUES (someid, 'some response that we would like to write');

# This database automatically puts a table in called tweets
SHOW TABLES IN my_twitter;
# should return
<!--
tweets
-->


SHOW COLUMNS FROM my_twitter.tweets;
# show these columns
<!-- 
'id',
'from'
'to', 
'conversation_id', 
'in_reply_to_tweet_id',
'text',
'query', 
'created_at', 
'is_retweet',
'is_reply',
'is_quote',
'is_verified',
'is_nullcast',
'hashtags',
'cashtags',
'links',
'mentions',
'media',
'lang',
'context',
'entities', 
'place', 
'place_country',
'place_geo_coordinates'
'attachments', 
'public_metrics'  -->


'''